//bear eat rabbit 20 points lol
#include<bits/stdc++.h>
using namespace std;
 
#define fi first
#define se second
#define pii pair<int,int>
#define pll pair<long long,long long>
#define pb push_back
#define debug(x) cerr<<#x<<"="<<x<<endl
#define pq priority_queue
#define inf 1ll<<60
#define rep(i,a,b) for (int i=a;i<(b);i++)
#define MP make_pair
#define SZ(x) (int(x.size()))
#define ll long long
#define mod 1000000007
#define ALL(x) x.begin(),x.end()
#define endl "\n"
void inc(ll &a,ll b) {a=(a+b)%mod;}
void dec(ll &a,ll b) {a=(a-b+mod)%mod;}
int lowbit(ll x) {return x&(-x);}
ll p0w(ll base,ll p) {ll ret=1;while(p>0){if (p%2ll==1ll) ret=ret*base%mod;base=base*base%mod;p/=2ll;}return ret;}



mt19937 rng(chrono::system_clock::now().time_since_epoch().count());
int st=clock();
double alpha=0.99999,temp=100000000;
vector<ll>alist;
ll n;

ll calc(vector<ll>curr){
	ll sum=0;
	rep(i,0,n){
		if(curr[i])sum+=alist[i];
	}
	return sum;
}
vector<ll>adj(vector<ll>curr){
	ll i=rng()%n;
	if(curr[i]==0){
		if(i-1>=0){
			curr[i-1]=0;
		}
		if(i+1<n){
			curr[i+1]=0;
		}
	}
	curr[i]^=1;
	return curr;
}
double P(ll jiu,ll xin,double t){
	if(jiu<xin)return 1.0;
	else{
		return exp((xin-jiu)/t);
	}
}
void solve(){
	vector<ll>best,curr;
	rep(i,0,n){
		curr.pb(0);
	}
	best=curr;
	while(clock()-st<1.25*CLOCKS_PER_SEC){
		vector<ll>next=adj(curr);
		ll curr_val=calc(curr);
		ll new_val=calc(next);
		if(new_val<=curr_val){
			best=curr;
		}
		if(P(curr_val,new_val,temp) >= (double)rng()/(double)RAND_MAX){
			curr=next;
		}
		temp*=alpha;
	}
	cout<<calc(best);
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	//freopen("C:\\Users\\xinan\\Downloads\\beareatrabbit_8.in", "r", stdin);
	cin>>n;
	rep(i,0,n){
		ll a;cin>>a;alist.pb(a);
	}
	solve();
	return 0;
}

//template 
Let s = random(state) //get's any random valid state
Let best = s
while elapsed_time() <= time_limit:
    Let t = temperature(elapsed_time()/time_limit) //returns temperature given the percent done
    Let next = neighbor(s) //neighbor of a state
    if value(s) < value(best):
        best = s
    if P(value(s), value(next), t) >= random(0, 1): //P -> probability of acceptance function, returns the probability that you'll move to the next state given the value's and the current temperature
        s = next

print(value(best))
